# ast2graph統合機能の実装計画

## 概要
graph_postgres_managerライブラリにast2graphライブラリとの統合機能を実装し、ASTグラフデータをNeo4jに効率的に保存できるようにする。

## 背景
- ast2graphライブラリはPythonコードのAST（抽象構文木）をグラフ構造に変換する
- graph_postgres_managerはこのグラフデータを受け取り、Neo4jに保存する責務を持つ
- 目標性能: 10,000ノード/秒以上のインポート速度

## 実装タスク

### 1. データモデルの定義
- [ ] ast2graphの出力形式を分析
- [ ] ASTNodeモデルクラスの作成
  - id: str
  - node_type: str
  - value: Optional[str]
  - lineno: Optional[int]
  - source_id: str
- [ ] エッジタイプの定義
  - CHILD: 親子関係
  - NEXT: 兄弟関係
  - DEPENDS_ON: 依存関係

### 2. store_ast_graphメソッドの実装
- [ ] GraphPostgresManagerにstore_ast_graphメソッドを追加
- [ ] 入力パラメータ:
  - graph_data: Dict[str, Any] (ast2graphの出力)
  - source_id: str (ソースコード識別子)
  - metadata: Optional[Dict[str, Any]]
- [ ] バリデーション機能の実装
  - グラフ構造の整合性チェック
  - 必須フィールドの存在確認
  - データ型の検証

### 3. バッチインポートの最適化
- [ ] Neo4jのAPOCプロシージャを使用した高速インポート
- [ ] バッチサイズの動的調整機能
- [ ] 並列処理による性能向上
- [ ] トランザクション管理との統合

### 4. インデックスとクエリ最適化
- [ ] ASTノード用のインデックス作成
  - CREATE INDEX ON :ASTNode(id)
  - CREATE INDEX ON :ASTNode(source_id)
  - CREATE INDEX ON :ASTNode(node_type)
- [ ] 頻繁に使用されるクエリパターンの最適化

### 5. エラーハンドリングと監視
- [ ] 部分的な失敗に対する復旧機能
- [ ] インポート進捗のログ出力
- [ ] パフォーマンスメトリクスの収集

### 6. テストの実装
- [ ] ユニットテスト
  - データバリデーション
  - エラーハンドリング
- [ ] 統合テスト
  - 実際のast2graph出力を使用したテスト
  - パフォーマンステスト（10,000ノード/秒の検証）
- [ ] エンドツーエンドテスト

### 7. ドキュメントの作成
- [ ] APIドキュメント
- [ ] 使用例の作成
- [ ] パフォーマンスチューニングガイド

## 技術的考慮事項

### パフォーマンス最適化戦略
1. **UNWIND文の使用**: 大量のノード/エッジ作成
2. **パラメータ化クエリ**: クエリプランのキャッシュ
3. **バッチサイズ**: 1,000〜5,000ノード/バッチが最適
4. **並列処理**: 複数のワーカースレッドでバッチを処理

### データ整合性
- トランザクション内でのインポート
- 重複ノードの検出と処理
- 参照整合性の保証

### スケーラビリティ
- メモリ効率的なストリーミング処理
- 大規模グラフ（100万ノード以上）への対応
- 増分更新のサポート

## 成功指標
- [ ] 10,000ノード/秒以上のインポート速度
- [ ] 99.9%以上のデータ整合性
- [ ] メモリ使用量: 1GBあたり100万ノード以下
- [ ] エラー率: 0.01%以下

## スケジュール
- データモデル定義: 1日
- 基本実装: 2日
- 最適化: 2日
- テスト: 1日
- ドキュメント: 1日
合計: 1週間

## リスクと対策
- **リスク**: ast2graphの出力形式変更
  - **対策**: バージョン管理とスキーマバリデーション
- **リスク**: パフォーマンス目標未達成
  - **対策**: プロファイリングとボトルネック分析
- **リスク**: メモリ不足
  - **対策**: ストリーミング処理とバッチサイズ調整

## 次のステップ
1. ast2graphライブラリのインターフェース確認
2. テスト用のサンプルデータ取得
3. パフォーマンステスト環境の準備