# インメモリモック設計書

**作成日**: 2025-07-03 23:00  
**対象**: graph_postgres_manager インメモリモック実装  
**方針**: 完全インメモリ、ゼロ依存、超高速

## 設計思想

### コア原則
1. **完全インメモリ**: ファイルI/O、ネットワーク一切なし
2. **ゼロ依存**: Python標準ライブラリのみ
3. **超高速**: 実装の1000倍以上の速度
4. **API互換**: 100%同じインターフェース
5. **テスト特化**: 本番用途は想定せず

## データ構造設計

### 1. InMemoryDataStore
```python
from typing import Dict, List, Set, Any, Optional
from collections import defaultdict
import uuid
import time

class InMemoryDataStore:
    def __init__(self):
        # Neo4j データ構造
        self.nodes: Dict[str, Dict[str, Any]] = {}
        self.relationships: List[Dict[str, Any]] = []
        self.labels: Dict[str, Set[str]] = defaultdict(set)
        self.node_relationships: Dict[str, List[int]] = defaultdict(list)
        
        # PostgreSQL データ構造
        self.tables: Dict[str, List[Dict[str, Any]]] = defaultdict(list)
        self.schemas: Dict[str, Dict[str, str]] = {}
        self.indexes: Dict[str, Dict[str, Any]] = {}
        
        # 検索インデックス（簡易）
        self.text_search: Dict[str, Set[str]] = defaultdict(set)
        self.vector_data: Dict[str, List[float]] = {}
        
        # トランザクション管理
        self.transaction_log: List[Dict[str, Any]] = []
        self.active_transactions: Dict[str, Dict[str, Any]] = {}
        self.transaction_data: Dict[str, Dict[str, Any]] = {}
        
        # 統計情報
        self.query_count = 0
        self.operation_times: List[float] = []
    
    def clear(self) -> None:
        """全データをクリア（テスト間のリセット用）"""
        self.__init__()
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        return {
            "nodes_count": len(self.nodes),
            "relationships_count": len(self.relationships),
            "tables_count": len(self.tables),
            "query_count": self.query_count,
            "avg_operation_time": sum(self.operation_times) / len(self.operation_times) if self.operation_times else 0
        }
```

### 2. Neo4j データ管理
```python
class Neo4jInMemoryEngine:
    def __init__(self, store: InMemoryDataStore):
        self.store = store
    
    def create_node(self, labels: List[str], properties: Dict[str, Any]) -> str:
        """ノード作成"""
        node_id = str(uuid.uuid4())
        
        # ノードデータ保存
        self.store.nodes[node_id] = {
            "labels": labels,
            "properties": properties
        }
        
        # ラベルインデックス更新
        for label in labels:
            self.store.labels[label].add(node_id)
        
        # テキスト検索インデックス更新
        for key, value in properties.items():
            if isinstance(value, str):
                words = value.lower().split()
                for word in words:
                    self.store.text_search[word].add(node_id)
        
        return node_id
    
    def create_relationship(self, source_id: str, target_id: str, 
                          rel_type: str, properties: Dict[str, Any] = None) -> int:
        """リレーションシップ作成"""
        rel_id = len(self.store.relationships)
        
        relationship = {
            "id": rel_id,
            "source": source_id,
            "target": target_id,
            "type": rel_type,
            "properties": properties or {}
        }
        
        self.store.relationships.append(relationship)
        self.store.node_relationships[source_id].append(rel_id)
        self.store.node_relationships[target_id].append(rel_id)
        
        return rel_id
    
    def match_nodes(self, labels: Optional[List[str]] = None, 
                   properties: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """ノード検索（簡易MATCH）"""
        results = []
        
        # ラベルでフィルター
        candidate_nodes = set(self.store.nodes.keys())
        if labels:
            for label in labels:
                if label in self.store.labels:
                    candidate_nodes &= self.store.labels[label]
                else:
                    return []  # ラベルが存在しない
        
        # プロパティでフィルター
        for node_id in candidate_nodes:
            node = self.store.nodes[node_id]
            
            if properties:
                match = True
                for key, value in properties.items():
                    if key not in node["properties"] or node["properties"][key] != value:
                        match = False
                        break
                if not match:
                    continue
            
            results.append({
                "id": node_id,
                "labels": node["labels"],
                "properties": node["properties"]
            })
        
        return results
```

### 3. PostgreSQL データ管理
```python
class PostgreSQLInMemoryEngine:
    def __init__(self, store: InMemoryDataStore):
        self.store = store
    
    def create_table(self, table_name: str, schema: Dict[str, str]) -> None:
        """テーブル作成"""
        self.store.schemas[table_name] = schema
        if table_name not in self.store.tables:
            self.store.tables[table_name] = []
    
    def insert(self, table_name: str, data: Dict[str, Any]) -> int:
        """レコード挿入"""
        if table_name not in self.store.tables:
            raise ValueError(f"Table {table_name} does not exist")
        
        # ID自動生成（idカラムがある場合）
        if "id" in self.store.schemas.get(table_name, {}) and "id" not in data:
            data["id"] = len(self.store.tables[table_name]) + 1
        
        self.store.tables[table_name].append(data.copy())
        return len(self.store.tables[table_name]) - 1
    
    def select(self, table_name: str, where: Optional[Dict[str, Any]] = None, 
              limit: Optional[int] = None) -> List[Dict[str, Any]]:
        """レコード取得"""
        if table_name not in self.store.tables:
            return []
        
        results = []
        for record in self.store.tables[table_name]:
            # WHERE条件チェック
            if where:
                match = True
                for key, value in where.items():
                    if key not in record or record[key] != value:
                        match = False
                        break
                if not match:
                    continue
            
            results.append(record.copy())
            
            # LIMIT処理
            if limit and len(results) >= limit:
                break
        
        return results
    
    def update(self, table_name: str, data: Dict[str, Any], 
              where: Dict[str, Any]) -> int:
        """レコード更新"""
        if table_name not in self.store.tables:
            return 0
        
        updated_count = 0
        for record in self.store.tables[table_name]:
            # WHERE条件チェック
            match = True
            for key, value in where.items():
                if key not in record or record[key] != value:
                    match = False
                    break
            
            if match:
                record.update(data)
                updated_count += 1
        
        return updated_count
    
    def delete(self, table_name: str, where: Dict[str, Any]) -> int:
        """レコード削除"""
        if table_name not in self.store.tables:
            return 0
        
        original_count = len(self.store.tables[table_name])
        
        # 削除対象以外を残す
        self.store.tables[table_name] = [
            record for record in self.store.tables[table_name]
            if not all(
                key in record and record[key] == value
                for key, value in where.items()
            )
        ]
        
        return original_count - len(self.store.tables[table_name])
```

## 実装優先度

### Phase 1: 最小実装
- [x] 設計書作成
- [ ] InMemoryDataStore 基本クラス
- [ ] MockGraphPostgresManager 骨格
- [ ] 基本的なノード作成・取得

### Phase 2: 主要機能
- [ ] Neo4j操作の実装
- [ ] PostgreSQL操作の実装
- [ ] トランザクション管理
- [ ] エラーシミュレーション

### Phase 3: 高度機能
- [ ] 検索機能
- [ ] バッチ操作
- [ ] 統計・監視機能
- [ ] テスト支援機能

## パフォーマンス目標

| 操作 | 目標時間 |
|------|----------|
| 初期化 | < 0.1秒 |
| ノード作成 | < 0.001秒 |
| ノード検索 | < 0.01秒 |
| レコード挿入 | < 0.001秒 |
| データリセット | < 0.01秒 |

## メモリ使用量

- **小規模テスト**: < 10MB
- **中規模テスト**: < 100MB  
- **大規模テスト**: < 1GB（制限として明記）

この設計により、テスト用途に特化した超高速なモック実装を提供します。